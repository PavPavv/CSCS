# Basic computer hardware design

## BASIC COMPUTING CONCEPTS

### A Closer Look at Memory Accesses: Register vs. Immediate

Notes from Jon Stokes "Understanding the machine" book

Code and data are logically separated in main memory, and that data flows into the processor from a data storage area, while code flows into the processor from a special code storage area. Main memory itself is just one long row of undifferentiated memory cells, each one byte in width, that store numbers. The computer carves up this long row of bytes into multiple segments, some of which store code and some of which store data.

> base address + offset, where offset is the distance in bytes of the desired memory location from the data segment’s base address.

_load #(D + 108)_ - A Read the contents of the memory cell at location #(D + 108) into A.
_store B, #(D + 108)_ - Write the contents of B into the memory cell at location #(D + 108).

By using register-relative addressing instead of absolute addressing (in which memory addresses are given as immediate values), a programmer can write
programs without knowing the exact location of data in memory. All the programmer needs to know is which register the operating system will place the data segment’s base address in.

> both memory addresses and instructions are ordinary numbers that can be stored in memory. A program is one long string of numbers stored in a series of memory locations.

## THE MECHANICS OF PROGRAM EXECUTION

Example of mnemonics to opcodes:

| Mnemonic | Opcode |
| -------- | ------ |
| add      | 000    |
| sub      | 001    |
| load     | 010    |
| store    | 011    |
| A        | 00     |
| B        | 01     |
| C        | 10     |
| D        | 11     |

The binary values representing both the opcodes and the register codes are arranged in one of a number of 16-bit (or 2-byte) formats to get a complete **machine language instruction**, which is a binary number that can be stored in RAM and used by the processor:

Byte 1
0 - mode | 1 2 3 - opcode | 4 5 - source1 | 6 7 - source2 |

Byte 2
8 9 - destination | 10 11 12 13 14 15 - 000000

### The Programming Model

The programming model is the programmer’s interface to the microprocessor.

The ALU performs arithmetic, the registers store numbers, and the input-output unit (I/O unit) is responsible for interacting with memory and the rest of the system (via loads and stores). The parts of the processor that we haven’t yet met lie in the control unit. Of these, we’ll cover the program counter and the instruction register now.

Because programs are stored in memory as ordered sequences of instructions and memory is arranged as a linear series of addresses, each instruction in a program lives at its own memory address. In order to step through and execute the lines of a program, the computer simply begins at the program’s starting address and then steps through each successive memory location, fetching each successive instruction from memory, placing it in a special register, and executing it.

> The **fetch-execute loop** is repeated for as long as the computer is powered on.

The
machine iterates through the entire loop, from step 1 to step 3, over and over again many millions or billions of times per second in order to run programs.

Steps of program execution don’t take an arbitrary amount of time to complete. Rather, they’re performed according to the pulse of the
clock that governs every action the processor takes. This clock pulse, which is generated by a clock generator module on the motherboard and is fed into the processor from the outside, times the functioning of the processor so that, on the DLW-1 at least, all three steps of the fetch-execute loop are completed in exactly one beat of the clock.

### Branch Instructions

Because a program is an ordered sequence of instructions, by including forward and backward branch instructions, we can arbitrarily move about in the program. This is a powerful ability, and branches are an essential part of computing. All branches as being one of the following two types: conditional branches or unconditional branches. Because of such conditional jumps, we need a special register or set of registers in which to store information about the results of arithmetic instructions—information such as whether the previous result was zero or nonzero, positive or negative, and so on.
Different architectures handle this in different ways, but in our DLW-1, this is the function of the processor status word (PSW) register.

The microprocessor, in its power-on default state, is hard-wired to fetch that first instruction from a predetermined address in memory. This first instruction, which is loaded into the processor’s instruction register, is the first line of a program called the BIOS that lives in a special set of storage locations—a small read-only memory (ROM) module attached to the computer’s motherboard. It’s the job of the BIOS to perform basic tests of the RAM and peripherals in order to verify that everything is working properly. Then the boot process can continue.

At the end of the BIOS program lies a jump instruction, the target ofwhich is the location of a bootloader program. By using a jump, the BIOS hands off control of the system to this second program, whose job it is to search for and load the computer’s operating system from the hard disk. The operating system (OS) loads and unloads all of the other programs that run on the computer, so once the OS is up and running the computer is ready to interact with the user.

## PIPELINED EXECUTION
